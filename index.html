<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Map OpenLayers</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"> <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.4/xlsx.full.min.js"></script> <!-- Include SheetJS library -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            left: 300px;
            bottom: 30px;
            width: calc(100% - 300px);
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            height: calc(100% - 40px);
            width: 300px;
            background-color: #f8f9fa; /* Light gray background */
            padding: 10px;
            box-sizing: border-box;
            text-align: left; /* Align text to the left */
            overflow-y: auto;
        }

        .pointer {
            font-size: 24px;
            color: red;
            position: absolute;
            z-index: 1000;
         }

         .popup {
            position: absolute;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            top: 20px;
            right: 20px;
        }

        .control-box {
            margin-bottom: 10px;
        }

        .control-box label {
            display: block; /* Each label on a new line */
            margin-bottom: 5px; /* Add space between labels */
            font-weight: bold; /* Make label text bold */
        }

        .control-box input[type="text"],
        .control-box input[type="range"],
        .control-box button {
            width: 100%; /* Take up full width */
            padding: 5px; /* Add padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .control-box button {
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
        }

        .control-box button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }
    </style>
</head>
<body>
<div id="popup" class="popup"></div>
<div id="controls">
    <div class="control-box">
        <label for="visible0">Kaart:</label>
        <input id="visible0" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible1">Sectie schakelaars:</label>
        <input id="visible1" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visible2">Voedingen:</label>
        <input id="visible2" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="opacity1">Transparantie schakelaars:</label>
        <input id="opacity1" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="opacity2">Transparantie voedingen:</label>
        <input id="opacity2" class="opacity" type="range" min="0" max="1" step="0.01"/>
    </div>
    <div class="control-box">
        <label for="searchInput">Zoek op adres, voeding of schakelaar:</label>
        <input id="searchInput" type="text"/>
    </div>
    <div class="control-box">
        <button onclick="zoomToLocationOrLayer()">Zoeken</button>
        <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
    </div>
    <div class="control-box">
        <button id="tekenButton" onclick="toggleDrawing()">Teken</button>
    </div>
</div>
<div id="map"></div>

<script>
    let map;
    let draw;

    // Load JSON file from server
    async function loadJSONFile() {
        try {
            const response = await fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/sectieschakelaars.json'); // Update the path as needed
            if (!response.ok) {
                throw new Error('Failed to fetch JSON file');
            }
            return await response.json();
        } catch (error) {
            console.error('Error loading JSON file:', error);
            throw error;
        }
    }

    // Function to find the S-value corresponding to a given V-value
    async function findSValue(vValue) {
        try {
            // Load JSON file from server
            const response = await fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/sectieschakelaars.json'); // Update the path as needed
            if (!response.ok) {
                throw new Error('Failed to fetch JSON file');
            }
            const jsonData = await response.json();

            // Find the corresponding S-value for the given V-value
            const sValueRow = jsonData.find(row => row[0] === vValue);

            // Return the S-value if found
            return sValueRow ? sValueRow[1] : 'Not found';
        } catch (error) {
            console.error('Error reading JSON file:', error);
            throw error;
        }
    }

    const center = ol.proj.fromLonLat([4.4024643, 51.2194475]);
    const extentSize = 25000; // Size of the extent in meters (10 km = 10000 meters)
    const extent = ol.extent.buffer(center.concat(center), extentSize);

    const view = new ol.View({
        center: center,
        zoom: 13,
        extent: extent // Set the extentt
    });

    let popupDisplayed = false;
    let drawingModeActive = false;
    let drawnFeaturesSource = new ol.source.Vector(); // Source to hold drawn features
    let drawnFeaturesLayer = new ol.layer.Vector({ // Layer to display drawn features
        source: drawnFeaturesSource,
    });

    map = new ol.Map({
        layers: [
            new ol.layer.Tile({
                source: new ol.source.TileJSON({
                    url: 'https://api.maptiler.com/maps/basic-v2/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
                    tileSize: 512,
                })
            })
        ],
        target: 'map',
        view: view // Use the view with the custom extent
    });

    const pointerElement = document.createElement('i');
    pointerElement.className = 'pointer fa-solid fa-location-dot';
    const pointerOverlay = new ol.Overlay({
        element: pointerElement,
        positioning: 'center-center',
        stopEvent: false
    });
    map.addOverlay(pointerOverlay);

    const popupElement = document.getElementById('popup');
    const popupOverlay = new ol.Overlay({
        element: popupElement,
        positioning: 'top-right',
        offset: [0, -10],
        stopEvent: false
    });
    map.addOverlay(popupOverlay);

    function toggleDrawing() {
        if (drawingModeActive) {
            // Clear previously drawn features if exiting drawing mode
            drawnFeaturesSource.clear();
            map.removeInteraction(draw);
            document.getElementById('tekenButton').style.backgroundColor = '';
        } else {
            // Clear previously drawn features if starting a new drawing
            drawnFeaturesSource.clear();
            document.getElementById('tekenButton').style.backgroundColor = 'green';
            initDrawingInteraction();
        }
        drawingModeActive = !drawingModeActive;
    }

    function initDrawingInteraction() {
        draw = new ol.interaction.Draw({
            source: drawnFeaturesSource,
            type: 'Polygon',
        });
        map.addInteraction(draw);

        draw.on('drawend', function(event) {
            // Clear previous polygon
            drawnFeaturesSource.clear();

            // Lock the current polygon
            const polygonFeature = event.feature;
            const polygonGeometry = polygonFeature.getGeometry();

            polygonFeature.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'blue',
                    width: 2,
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(0, 0, 255, 0.2)',
                }),
            }));

            // Add the drawn feature to the permanent layer
            drawnFeaturesSource.addFeature(polygonFeature);

            // Perform spatial query against features in Layer 2
            const intersectingFeatures = [];
            vectorLayer2.getSource().forEachFeature(function(feature) {
                const featureGeometry = feature.getGeometry();
                if (featureGeometry.intersectsPolygon(polygonGeometry)) {
                    intersectingFeatures.push(feature);
                }
            });
            // Display popup with information about intersecting features
            if (intersectingFeatures.length > 0) {
                const popupContent = intersectingFeatures.map(function(feature) {
                    const layerName = feature.get('LAYER');
                    const lonLat = ol.proj.toLonLat(feature.getGeometry().getCoordinates());
                    const lon = lonLat[0];
                    const lat = lonLat[1];
                    return `<p>Layer: ${layerName}</p><p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
                }).join('<hr>'); // Separate feature information with horizontal line
                popupElement.innerHTML = popupContent;
                const centroid = polygonGeometry.getInteriorPoint().getCoordinates(); // Get the centroid of the polygon
                const popupPosition = ol.proj.fromLonLat(centroid);
                popupOverlay.setPosition(popupPosition);
            } else {
                // If no intersecting features, display a message
                popupElement.innerHTML = '<p>No features found in the drawn area.</p>';
                popupOverlay.setPosition(undefined); // Hide popup
            }

            // Clear the drawing interaction (but keep it active)
            draw.finishDrawing();
        });
    }

    map.on('click', async function(event) {
        if(drawingModeActive) {
            //No functionality yet
        } else {
            const coordinates = event.coordinate;
            const transfcoordinates = ol.proj.transform(coordinates, 'EPSG:3857', 'EPSG:4326'); // Correct variable name
            let closestFeature = null;
            let closestDistance = Infinity;
            vectorLayer2.getSource().forEachFeature(function(feature) {
                const featureCoordinates = feature.getGeometry().getClosestPoint(coordinates);
                const featureCoords = ol.proj.transform(featureCoordinates, 'EPSG:3857', 'EPSG:4326');
                const distance = ol.sphere.getDistance(transfcoordinates, featureCoords);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestFeature = feature;
                }
            });

            if (closestFeature) {
                const closestFeatureName = closestFeature.get('LAYER');
                const lon = transfcoordinates[0];
                const lat = transfcoordinates[1];
                const vValue = closestFeatureName; // Example value, replace this with the actual V-value of the closest feature
                const sValue = await findSValue(vValue);
                const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p><p>Closest Feature: ${closestFeatureName}</p><p>S-value: ${sValue}</p>`;
                popupElement.innerHTML = content;
                popupOverlay.setPosition(coordinates);
            } else {
                const lon = transfcoordinates[0];
                const lat = transfcoordinates[1];
                const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
                popupElement.innerHTML = content;
                popupOverlay.setPosition(coordinates);
            }

            pointerOverlay.setPosition(coordinates);
        }
    });

    map.on('dblclick', function(event) {
        if (drawingModeActive) {
            // Prevent map zoom on double-click during drawing mode
            event.preventDefault();
        }
    });

    map.getViewport().addEventListener('contextmenu', function(event) {
        if (drawingModeActive) {
            // Finish drawing on right-click
            event.preventDefault();
            draw.finishDrawing();
        }
    });
    map.addLayer(drawnFeaturesLayer);

    // Object to store the colors for each layer
    const layerColors = {};

    // Load GeoJSON data for the first layer
    const geojsonSource1 = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/schakelaars2.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the first layer (dots) with red/green color and label
    const geojsonStyle1 = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property;
        const color = 'red'; // Set color to red
        // Create style for the feature
        return new ol.style.Style({
            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: color // Use the color
                }),
                stroke: new ol.style.Stroke({
                    color: color, // Use the color
                    width: 2
                })
            }),
            text: new ol.style.Text({
                text: layerName, // Display the layer name as label
                font: '12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: color }) // Use the same color for the label
            })
        });
    };

    // Create the first vector layer
    const vectorLayer1 = new ol.layer.Vector({
        source: geojsonSource1,
        style: geojsonStyle1
    });

    // Add the first vector layer to the map
    map.addLayer(vectorLayer1);

    // Load GeoJSON data for the second layer
    const geojsonSource2 = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voedingen3.geojson',
        format: new ol.format.GeoJSON()
    });

    // Style for the second layer (lines) with dynamic color and label
    const geojsonStyle2 = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property
        let color;
        if (layerColors[layerName]) {
            // If color is already assigned, reuse it
            color = layerColors[layerName];
        } else {
            // Otherwise, generate a new random color and store it
            color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            layerColors[layerName] = color;
        }
        // Create style for the feature
        return new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: color, // Use the color
                width: 3
            }),
            text: new ol.style.Text({
                text: layerName, // Display the layer name as label
                font: '12px Calibri,sans-serif',
                offsetY: -12,
                fill: new ol.style.Fill({ color: color }) // Use the same color for the label
            })
        });
    };

    // Create the second vector layer with the dynamic style function
    const vectorLayer2 = new ol.layer.Vector({
        source: geojsonSource2,
        style: geojsonStyle2
    });

    // Add the second vector layer to the map
    map.addLayer(vectorLayer2);

    // Troubleshooting: Add an event listener to check for errors
    vectorLayer2.getSource().on('change', function(evt) {
        if (vectorLayer2.getSource().getState() === 'ready') {
            console.log('Data loaded successfully.');
        } else if (vectorLayer2.getSource().getState() === 'error') {
            console.error('Error loading data:', vectorLayer2.getSource().getLoadingError());
        }
    });

    // Function to handle layer visibility
    function handleLayerVisibility(layer, checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        checkbox.addEventListener('change', function() {
            layer.setVisible(this.checked);
        });
    }

    // Function to handle layer opacity
    function handleLayerOpacity(layer, rangeId) {
        const rangeInput = document.getElementById(rangeId);
        rangeInput.addEventListener('input', function() {
            layer.setOpacity(parseFloat(this.value));
        });
        rangeInput.value = String(layer.getOpacity());
    }

    // Function to zoom to a specific location or layer
    function zoomToLocationOrLayer() {
        const searchText = document.getElementById('searchInput').value;
        if (searchText) {
            let foundLayer2 = false;
            let foundLayer1 = false;
            // Check if the search text matches a feature in Layer 2
            vectorLayer2.getSource().forEachFeature(function(feature) {
                if (feature.get('LAYER') === searchText) {
                    const extent = feature.getGeometry().getExtent();
                    map.getView().fit(extent, { duration: 1000 });
                    foundLayer2 = true;
                    return;
                }
            });
            // If not found in Layer 2, check Layer 1
            if (!foundLayer2) {
                vectorLayer1.getSource().forEachFeature(function(feature) {
                    if (feature.get('LAYER') === searchText) {
                        const extent = feature.getGeometry().getExtent();
                        map.getView().fit(extent, { duration: 1000 });
                        foundLayer1 = true;
                        return;
                    }
                });
            }
            // If not found in Layer 1, try to geocode the search text as an address
            if (!foundLayer2 && !foundLayer1) {
                geocodeAddress(searchText);
            }
            // Display error message if nothing is found
            if (!foundLayer2 && !foundLayer1 && !searchText) {
                document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
            } else {
                document.getElementById('errorMessage').textContent = ''; // Clear error message
            }
        } else {
            document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
        }
    }


    // Function to geocode an address and zoom to its location
    function geocodeAddress(address) {
        const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + encodeURIComponent(address);
        fetch(url)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                if (data && data.length > 0) {
                    const location = data[0];
                    const coordinates = [parseFloat(location.lon), parseFloat(location.lat)];
                    map.getView().animate({ center: ol.proj.fromLonLat(coordinates), zoom: 18, duration: 1000 });
                } else {
                    alert('Address not found!');
                }
            })
            .catch(function(error) {
                console.error('Error geocoding address:', error);
            });
    }

    // Handle visibility for OSM layer
    handleLayerVisibility(map.getLayers().item(0), 'visible0');

    // Handle visibility for QGIS layer 1
    handleLayerVisibility(vectorLayer1, 'visible1');

    // Handle visibility for QGIS layer 2
    handleLayerVisibility(vectorLayer2, 'visible2');

    // Handle opacity for QGIS layer 1
    handleLayerOpacity(vectorLayer1, 'opacity1');

    // Handle opacity for QGIS layer 2
    handleLayerOpacity(vectorLayer2, 'opacity2');
</script>
</body>
</html>